S1H["S1(H)=13.2-3=10.2"]
S1T["S1(T)=11.40-3=8.4"]
S2HH["S2(HH)=11.22"]
S2HT["S2(HT)= 9.69"]
S2TH["S2(TH)=12.54"]
S2TT["S2(TT)=10.83"]
S0 --- S1H
S0 --- S1T
S1H --- S2HH
S1H --- S2HT
S1T --- S2TH
S1T --- S2TT
')
library(DiagrammeR)
mermaid('
graph LR
S0["S0=12"]
S1H["S1(H)=13.2-3=10.2"]
S1T["S1(T)=11.40-3=8.4"]
S2HH["S2(HH)=11.22"]
S2HT["S2(HT)= 9.69"]
S2TH["S2(TH)=9.24"]
S2TT["S2(TT)=7.98"]
S0 --- S1H
S0 --- S1T
S1H --- S2HH
S1H --- S2HT
S1T --- S2TH
S1T --- S2TT
')
library(DiagrammeR)
mermaid('
graph LR
S0["S0=12"]
S1H["S1(H)=13.2-3=10.2"]
S1T["S1(T)=11.40-3=8.4"]
S2HH["S2(HH)=11.22"]
S2HT["S2(HT)= 9.69"]
S2TH["S2(TH)=9.24"]
S2TT["S2(TT)=7.98"]
S0 --- S1H
S0 --- S1T
S1H --- S2HH
S1H --- S2HT
S1T --- S2TH
S1T --- S2TT
')
library(DiagrammeR)
mermaid('
graph LR
S0["S0=12"]
S1H["S1(H)=13.2-3=10.2"]
S1T["S1(T)=11.40-3=8.4"]
S2HH["S2(HH)=11.22"]
S2HT["S2(HT)= 9.69"]
S2TH["S2(TH)=9.24"]
S2TT["S2(TT)=7.98"]
S0 --- S1H
S0 --- S1T
S1H --- S2HH
S1H --- S2HT
S1T --- S2TH
S1T --- S2TT
')
# Input parameters
u <- 1.1
d <- 0.95
r <- 0.02
# Calculate risk-neutral probabilities
p_tilde <- (1 + r - d) / (u - d)
q_tilde <- (u - 1 - r) / (u - d)
# Verify that p_tilde + q_tilde = 1
sum_pq <- p_tilde + q_tilde
# Print results
cat("Risk-neutral probability p_tilde: ", p_tilde, "\n")
cat("Risk-neutral probability q_tilde: ", q_tilde, "\n")
# Input parameters
u <- 1.20
d <- 0.90
r <- 0.10
# Calculate risk-neutral probabilities
p_tilde <- (1 + r - d) / (u - d)
q_tilde <- (u - 1 - r) / (u - d)
# Print results
cat("Risk-neutral probability p_tilde: ", p_tilde, "\n")
cat("Risk-neutral probability q_tilde: ", q_tilde, "\n")
# Input parameters
u <- 1.1
d <- 0.95
r <- 0.02
# Calculate risk-neutral probabilities
p_tilde <- (1 + r - d) / (u - d)
q_tilde <- (u - 1 - r) / (u - d)
# Print results
cat("Risk-neutral probability p_tilde: ", p_tilde, "\n")
cat("Risk-neutral probability q_tilde: ", q_tilde, "\n")
# Input parameters
S0 <- 100  # initial stock price
v <- 0.1   # volatility
r <- 0.05  # risk-free rate
X <- 100   # strike price
T <- 0.5   # time to expiration in years
# Calculate d1 and d2
d1 <- (log(S0 / X) + (r + v^2 / 2) * T) / (v * sqrt(T))
d2 <- d1 - v * sqrt(T)
# Print the values for d1 and d2
print(d1)
print(d2)
# Input parameters
S0 <- 100  # initial stock price
v <- 0.1   # volatility
r <- 0.05  # risk-free rate
X <- 100   # strike price
T <- 0.5   # time to expiration in years
# Calculate d1 and d2
d1 <- (log(S0 / X) + (r + v^2 / 2) * T) / (v * sqrt(T))
d2 <- d1 - v * sqrt(T)
# Print the values for d1 and d2
cat("d1: ",d1)
print(d2)
# Input parameters
S0 <- 100  # initial stock price
v <- 0.1   # volatility
r <- 0.05  # risk-free rate
X <- 100   # strike price
T <- 0.5   # time to expiration in years
# Calculate d1 and d2
d1 <- (log(S0 / X) + (r + v^2 / 2) * T) / (v * sqrt(T))
d2 <- d1 - v * sqrt(T)
# Print the values for d1 and d2
cat("d1: ",d1)
cat("d2: ",d2)
# Input parameters
S0 <- 100  # initial stock price
v <- 0.1   # volatility
r <- 0.05  # risk-free rate
X <- 100   # strike price
T <- 0.5   # time to expiration in years
# Calculate d1 and d2
d1 <- (log(S0 / X) + (r + v^2 / 2) * T) / (v * sqrt(T))
d2 <- d1 - v * sqrt(T)
# Print the values for d1 and d2
cat("d1: ",d1,"\n")
cat("d2: ",d2)
# Continue from the previous script
# Calculate the call option price
C <- S0 * pnorm(d1) - X * exp(-r * T) * pnorm(d2)
# Print the call option price
print(C)
# Continue from the previous script
# Calculate the call option price
C <- S0 * pnorm(d1) - X * exp(-r * T) * pnorm(d2)
# Print the call option price
cat("BSM Call option price: ",C,"\n")
# Calculate the put option price
P <- X * exp(-r * T) * pnorm(-d2) - S0 * pnorm(-d1)
# Print the put option price
cat("BSM Put option price: ",P,"\n")
# Define the values
S <- 100    # Stock price
sigma <- 0.1   # Volatility
r <- 0.05   # Risk-free rate
K <- 100    # Strike price
T <- 0.5    # Time to maturity
# Calculate d1 and d2
d1 <- (log(S / K) + (r + 0.5 * sigma^2) * T) / (sigma * sqrt(T))
d2 <- d1 - sigma * sqrt(T)
# Calculate option prices
call <- S * pnorm(d1) - K * exp(-r * T) * pnorm(d2)
put <- K * exp(-r * T) * pnorm(-d2) - S * pnorm(-d1)
# Calculate the greeks
delta_call <- pnorm(d1)
delta_put <- pnorm(d1) - 1
gamma <- dnorm(d1) / (S * sigma * sqrt(T))
theta_call <- - (S * sigma * dnorm(d1)) / (2 * sqrt(T)) - r * K * exp(-r * T) * pnorm(d2)
theta_put <- - (S * sigma * dnorm(d1)) / (2 * sqrt(T)) + r * K * exp(-r * T) * pnorm(-d2)
vega <- S * sqrt(T) * dnorm(d1)
rho_call <- T * K * exp(-r * T) * pnorm(d2)
rho_put <- -T * K * exp(-r * T) * pnorm(-d2)
lambda_call <- S * pnorm(d1) / call
lambda_put <- S * (pnorm(d1) - 1) / put
# Print the results
cat("Call Option Price: ", call, "\n")
cat("Put Option Price: ", put, "\n")
cat("Call Option Delta: ", delta_call, "\n")
cat("Put Option Delta: ", delta_put, "\n")
cat("Gamma: ", gamma, "\n")
cat("Call Option Theta: ", theta_call, "\n")
cat("Put Option Theta: ", theta_put, "\n")
cat("Vega: ", vega, "\n")
cat("Call Option Rho: ", rho_call, "\n")
cat("Put Option Rho: ", rho_put, "\n")
cat("Call Option Lambda: ", lambda_call, "\n")
cat("Put Option Lambda: ", lambda_put, "\n")
# Calculate the put option price
P <- X * exp(-r * T) * pnorm(-d2) - S0 * pnorm(-d1)
# Print the put option price
cat("BSM Put option price: ",P,"\n")
setwd("/Volumes/LocalData/Developer/JHU-Data-Science/2. R Programming/week2")
if(x>3) {
y <- 10
} else{
y <- 0
}
x <-0
if(x>3) {
y <- 10
} else{
y <- 0
}
y <- if (x > 3) {
10
} else{
0
}
for(i in 1:10) {
print(i)
}
x <- c("a", "b", "c", "d")
for (i in 1:4) {
print(x[i])
}
for(i in seq_along(x)) {
print(x[i])
}
for(letter in x) {
print(letter)
}
for(i in 1:4) print(x[i])
x <- matrix(1:6, 2, 3)
for (i in seq_len(nrow(x))) {
for (j in seq_len(ncol(x))) {
print(x[i, j])
}
}
count <- 0
while (count < 10) {
print(count)
count <- count + 1
}
z <- 5
while (z >= 3 && z <= 10) {
print(z)
coin <- rbinom(1, 1, 0.5)
if (coin == 1) {
## random walk z<-z+1
} else{
z <- z - 1
}
}
x0 <- 1
tol <- 1e-8
repeat {
x1 <- computeEstimate()
if (abs(x1 - x0) < tol) {
break
} else{
x0 <- x1
}
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
## Do something here
}
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
## Do something here
print(i)
}
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
## Do something here
print(i)
}
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
}
## Do something here
print(i)
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
}
## Do something here
print(i)
if (i==25){
return
}
}
for(i in 1:100) {
if (i <= 20) {
## Skip the first 20 iterations
next
}
## Do something here
print(i)
if (i==25){
return
}
}
add2 <- function(x, y) {
x + y
}
add2 <- function(x, y) {
x + y
}
add2(1,2)
above10 <- function(x) {
use <- x > 10
x[use]
}
above <- function(x,n){
use <- x > n
x[use]
}
x <- 1:20
above(x,12)
above10 <- function(x) {
use <- x > 10
x[use]
}
above <- function(x,n=10){
use <- x > n
x[use]
}
x <- 1:20
above(x,12)
above(x)
above10 <- function(x) {
use <- x > 10
x[use]
}
above <- function(x,n=10){
use <- x > n
x[use]
}
x <- 1:20
above(x,12)
above(x)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numerci(nc)
for (i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numerci(nc)
for (i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
columnmean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(y[, i], na.rm = removeNA)
}
means
}
columnmean(airquality)
columnmean(airquality, FALSE)
mydata <- rnorm(100)
sd(mydata)
sd(x = mydata)
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)
sd(na.rm = FALSE, mydata)
args(lm)
f <- function(a,
b = 1,
c = 2,
d = NULL) {
}
f <- function(a, b) {
a ^ 2
}
f(2)
f <- function(a, b) {
print(a)
print(b)
}
f(45)
myplot <-
function(x, y, type = "l", ...) {
plot(x, y, type = type, ...)
}
mean
args(paste)
args(cat)
args(paste)
paste("a", "b", sep = ":")
paste("a", "b", se = ":")
lm <- function(x) {
x * x
}
lm
search()
make.power <- function(n) {
pow <- function(x) {
x ^ n
}
pow
}
cube <- make.power(3)
cube <- make.power(3)
square <- make.power(2)
cube
cube(3)
square(2)
ls(environment(cube))
get("n", environment(cube))
ls(environment(square))
get("n", environment(square))
y <- 10
f <- function(x) {
y <- 2
y ^ 2 + g(x)
}
g <- function(x) {
x * y
}
y
f(3)
g <- function(x) {
a <- 3
x + a + y
}
g(2)
y<-3
g(2)
make.NegLogLik <-
function(data, fixed = c(FALSE, FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <-
-0.5 * length(data) * log(2 * pi * sigma ^ 2) b <-
make.NegLogLik <-
function(data, fixed = c(FALSE, FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma ^ 2)
b <- -0.5 * sum((data - mu) ^ 2) / (sigma ^ 2) - (a + b)
}
}
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
ls(environment(nLL))
optim(c(mu = 0, sigma = 1), nLL)$par
make.NegLogLik <-
function(data, fixed = c(FALSE, FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5 * length(data) * log(2 * pi * sigma ^ 2)
b <- -0.5 * sum((data - mu) ^ 2) / (sigma ^ 2)
- (a + b)
}
}
set.seed(1); normals <- rnorm(100, 1, 2)
nLL <- make.NegLogLik(normals)
nLL
ls(environment(nLL))
optim(c(mu = 0, sigma = 1), nLL)$par
nLL <- make.NegLogLik(normals, c(FALSE, 2))
optimize(nLL, c(-1, 3))$minimum
nLL <- make.NegLogLik(normals, c(1, FALSE))
optimize(nLL, c(1e-6, 10))$minimum
nLL <- make.NegLogLik(normals, c(1, FALSE)) x <- seq(1.7, 1.9, len = 100)
nLL <- make.NegLogLik(normals, c(1, FALSE))
x <- seq(1.7, 1.9, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
nLL <- make.NegLogLik(normals, c(FALSE, 2))
x <- seq(0.5, 1.5, len = 100)
y <- sapply(x, nLL)
plot(x, exp(-(y - min(y))), type = "l")
